import os, sys, uuid, json

file_dir = os.path.dirname(os.path.realpath(__file__))  # xxx/src/
project_root_path = os.path.dirname(file_dir)  # xxx/helper_platform_detect

base_root = os.path.dirname(project_root_path)  # location where all projects reside
sys.path.append(base_root)

from common.ptb_framework.src.pirate import PTBEnv
from common.simpelTools.src.filetools import *
from common.simpelTools.src.command_carrier import *
from common.SW_Test_flasher.src.class_jasonixer import Jasonixer

# todo: inherit argparse from global. now only quick and dirty
import argparse


class EnvFlasher(PTBEnv):
    class c_ref_flasher:
        """
        This provides the runtime environment to a flasher installation. It was written to encapsulate it.
        this class can be included in a test to handle tests on netX level instead of dealing with the flasher and the
        detecion stuff.

        It's main purpoe is to support the install package of the ptb. So it includes the control of the flasher as a
        side effect.
        """

        def __init__(self, gPath_base_root, dict_json_version):

            """
            Retrieves all mandatory keys from the version-json dictionary generated by load_version_json(self).
            The reason of the early retriving is, that the test should fail immediatly if something is wrong.
            :return:none
            """

            # retrieve all values from the dictionary.
            assert (dict_json_version)  # dict not set, load version.json first!
            try:
                self.vFlasher = dict_json_version['VERSION_FLASHER']
                self.vDriverRomloaderWindows = dict_json_version['VERSION_DRIVER_WIN_BOOTLOADER']
                self.vRomloader = dict_json_version['VERSION_ROMLOADER_SINE']
                self.installApplyRomloaderPatch = dict_json_version[
                    'APPLY_ROMLOADER_PATCH']  # old flasher, new romloader, apply changes
                self.installApplyRomloaderTest = dict_json_version[
                    'APPLY_ROMLOADER_TEST']  # existing setup, add test for romloader
            except Exception as e:
                l.error('Parsed %s: %s' % (dict_json_version, e))
                raise e
            try:
                self.name_romloader_tar_source = dict_json_version[
                    'NAME_TMP_FINAL_ROMLOADER_PLUGIN_TAR_GZ']
            except Exception as e:
                l.error('Parsed key didn\'t exist?  %s' % e)
                raise e

            # use values from dictionary to generate all needed path
            # todo: probably give parameters as the json
            # flasher
            self.nLuaLin = "lua5.1.sh"
            self.nLuaWin = "lua5.1.exe"
            self.pathRel_flasher = 'flasher_cli-%s' % self.vFlasher  # path for extracting the flasher to (will be created by archive file)
            self.nTarFlasher = "flasher_cli-%s.tar.gz" % (self.vFlasher)
            self.gPathAbs_TarFlasher = os.path.join(gPath_base_root, self.nTarFlasher)
            self.gpathAbs_flasher = os.path.join(gPath_base_root, self.pathRel_flasher)
            self.nLuaFileRomloaderTest = "test_romloader.lua"  # placed beside lua.exe
            self.gPath_LuafileRomloaderSource = os.path.join(gPath_base_root, self.nLuaFileRomloaderTest)
            self.gPath_LuaFileRomloaderTarget = self.gpathAbs_flasher
            self.gPath_lua_binary = "set by function set_path_flasher_binary(self)"
            # where does the flasher binary come from?
            self.name_flasher_plugin_folder = 'lua_plugins'
            self.gPathAbs_flasher_luaplugin = os.path.join(self.gpathAbs_flasher, self.name_flasher_plugin_folder)
            self.name_file_cliFlash = 'cli_flash.lua'
            self.command_flasher_listInterfaces = "list_interfaces"
            self.command_flasher_detectNetx = "detect_netx"

            # subfolder
            self.grelrelPath_binNetX = 'netx'  # in lua folder
            self.grelrelPath_luaplugins = 'lua_plugins'

            # netxbins
            self.pathReg_binsNetX = 'netxbins'  # from zip
            self.gPath_binsNetxSource = os.path.join(gPath_base_root, self.pathReg_binsNetX)
            self.wildcardMontestBins = 'montest_*.bin'  # to copy all file at once
            self.gPath_binsNetxSourceWild = os.path.join(self.gPath_binsNetxSource, self.wildcardMontestBins)
            self.gPath_binsNetxTarget = os.path.join(self.gpathAbs_flasher, self.grelrelPath_binNetX)

            # flasher config files
            self.gPath_flasher_test_config = os.path.join(gPath_base_root)

            # Romloaderplugin
            self.gPath_romloader_tar_source = os.path.join(gPath_base_root, self.name_romloader_tar_source)

            pass

    def __init__(self, path_folder_logfiles, path_file_version_json, change_root_path_to=None):
        """
        In this monstrum we init all necessay variables for futher path an binary files.
        there might be a better way to do so, e.g. with a single json, which is acutally containing the relevant data.
        But this also does not change the fact that tere a several lines to be read. Ok, you could also hardcode
        everything in place and skip all the init stuff, but the benefit of the init stuff is, that it easy to
        manipulate and to be extended.
        :param path_folder_logfiles: Logfiles are createt for every test run. the location provides the root dir to them
        :param path_file_version_json: Ther version json is for information purpose and for transmitting the version
        of the flasher. the flasher version is contained in the folder to the flasher, which makes it mandatory to
        """

        ### parser
        self.parser = argparse.ArgumentParser("Initial Parser of class %s" % self.__class__.__name__)
        self.init_parse_args()

        ### netx

        PTBEnv.__init__(self, path_folder_logfiles)

        self.tmp_vFlasher = ''
        self.tmp_name_romloader_tar_source = ''

        # Global constants
        if change_root_path_to:
            self.gPath_base_root = change_root_path_to
        else:
            self.gPathScriptFile_precise = os.path.dirname(os.path.abspath(__file__))
            self.gPath_flasher_root = os.path.dirname(self.gPathScriptFile_precise)  # in SW_Test_flasher
            self.gPath_base_root = os.path.dirname(self.gPath_flasher_root)  # WB_Root
        self.path_json_version = path_file_version_json

        # load and init version json
        self.dict_json_version = self.load_version_json()
        # extract values from dict and build path
        self.ref_flash = self.c_ref_flasher(self.gPath_base_root, self.dict_json_version)  # reference flasher

        # use some provided infos from abouve
        self.set_path_flasher_binary()

    def init_parse_args(self):
        l.info("init parser")

        subparsers = self.parser.add_subparsers(help="subparser of class %s" % self.__class__.__name__)
        parser_install = subparsers.add_parser("install", help='manages the Installation of the package')
        parser_install.add_argument('--f32',
                                    help="force installation of 32bit version",
                                    action='store_true')

        parser_install.add_argument('--install',
                                    help="placeholder for actually executed installer",
                                    default=True)
        parser_install.add_argument('-P', '--test_romloader',
                                    action='store_true',
                                    help="add test_romloader.lua and according binaries to extracted flasher")

        parser_test = subparsers.add_parser("test", help="run the test")
        parser_test.add_argument('-u', '--uuid',
                                 default=None,
                                 help='The provided uuid from the test environment. '
                                      'will be passed to the Dyntest class as static var.')
        parser_test.add_argument('-lb', '--list_black',
                                 help="Blacklist reduces the selected ports to those which are not in the black list."
                                      " Kicks also white listed, if necessary.")
        parser_test.add_argument('-lw', '--list_white',
                                 help="White List of ports. Every used port must be content of the white list. "
                                      "White listed parameters can also be reduced by black list again.")
        parser_test.add_argument("-m", '--mode',
                                 choices=["regr_short", "regr_standard", "regr_long", "all"],
                                 default='fast',
                                 nargs='+',
                                 help="precision of the test")
        parser_test.add_argument("name",
                                 help="the name of the test to perform",
                                 choices=["flasher"])
        # self.args_result = self.parser.parse_args()
        # print(args)

    def load_version_json(self):

        try:
            if os.path.isfile(self.path_json_version):
                l.info('Found config file at: %s' % self.path_json_version)
            else:
                l.error('Expected configfile at: %s' % self.path_json_version)
                raise (BaseException("No logfile found at: %s" % self.path_json_version))
            json_data = open(self.path_json_version)
            jason_version_info = json.load(json_data)
            json_data.close()
        except Exception as e:
            l.error('Tried to retrieve version info from %s: %s' % (self.path_json_version, e))
            raise (e)
        return jason_version_info

    # Todo: control functions from here downwards!

    def main(self):
        '''
        Executing test, un with install32 and instead with the version related to the plattform of the host the
        installation will be forced to generate the 32bit flasher.
        if minimal is in the string, the romloader will not be patced, this can be useful for final packages.
        Also dpinst is not instaled but delivered and extracted. reason: no autoinstall of dpinst!
        :todo: Black/White Mask does not apply to flasher test!
        :return:
        '''
        iErr = -1
        ScriptProgramm = ''

        try:
            ScriptProgramm = sys.argv[1]
        except IndexError as e:
            print(
                "Please provide a command line argument ('install' for installsetup any other name for a module)  <%s>" % e)
            exit(-43)

        try:
            uuid_of_session = sys.argv[2]
            l.info("Running under inherited UUID: %s" % uuid_of_session)
        except IndexError as e:
            uuid_of_session = str(uuid.uuid4())
            l.info("Running under locally generated UUID: %s" % uuid_of_session)

        if ScriptProgramm:  # check if plugin is set
            if 'install' in ScriptProgramm:
                if '32' in ScriptProgramm:
                    l.info("Installing 32 bit version of Flasher")
                    force_32_bit_exec = True
                else:
                    l.info("Installing os conform version of Flasher")
                    force_32_bit_exec = False
                l.info("Performing installation")

                iErr = self.runInstallation(force_32_bit_exec)


            elif 'ptbt' in ScriptProgramm:

                l.info("Perform Test with plugin <%s>" % (ScriptProgramm))

                # input plugin name here
                # run_flasher_command_for_the_one_netx(str_full_absolute_commandstring)
                whitemask = []  # ['romloader_usb','romloader_uart'] # will only use for device selection romloader_usb
                blacklist = []  # ['romloader_uart']

                # init logfiles
                self.lfm.logfiles_manage_init()

                # Romloader test

                if 'test_romloader' in ScriptProgramm:
                    pass
                    # run romloader_test
                elif 'test_flasher' in ScriptProgramm:
                    # run flashertest
                    pass
                else:
                    tmp_err_msg = "No test named: %s" % ScriptProgramm
                    l.error(tmp_err_msg)
                    raise (BaseException(tmp_err_msg))
                if iErr == -1:
                    l.error("invalid command for specifying test: %s" % ScriptProgramm)

                # netX os etc in here!
                name_logfiles = self.lfm.gen_name_logfiles(['uuid', 'iterating_id', 'netx'])
                self.lfm.archive_logs(name_logfiles)

        else:
            raise (BaseException("Provide command line arguments!"))

        # error retruned from framework.
        # errors generated by the environment should be passed as json errors.
        # for the first shot, also errors from netX may change the errorvalue.
        return iErr

    # so fare so good! ( untested )
    def runInstallation(self, force32=False, apply_romloader_test=None):
        '''
        expect to have the Flasher archive which contains the flasher for all OS in one single folder in the root of archive
        todo: probably force the exception, get grid of i_err
        :param force32: forces the 32bit version of the flasher to be installed
        :return:
        '''
        for _ in (1,):
            i_err = None

            if force32 and platform.system() =='Linux':
                # ommit the force 32 bit, cause flasher does not have 32bit abilety for 64bit os!
                l.info("[install]: ignored 32bit installs for linux, cause of not supported for OS. install 64bit.")
                force32 = False

            if force32:
                l.info("[install]: install 32bit by force!")
            nameFlasherArchive = self.gen_name_flasher_archive(force32)

            # todo: make a "working dir" for the installer to extract those tar-files. probably
            # todo: clear this working dir before extracting those files
            # todo: create a directory, for the installed environment, so that his directory can be removed in before.
            # only extract th correct one.
            l.info("[pirate][install][extract]: OS-Independend flasher archive <%s> to <%s>" % (
                self.ref_flash.gPathAbs_TarFlasher, self.gPath_base_root))
            # flasher zip is already containing a sub folder with version name, so extract into the main archive
            extractTarGz(self.ref_flash.gPathAbs_TarFlasher,
                         self.gPath_base_root)

            self.install_flasher_version_unpack(nameFlasherArchive)

            # to test the romloader special binaries and test_romloader.lua have to be added to the target

            if apply_romloader_test:
                self.apply_test_romloader()

            # romloader removes the romloader from the flasher and replaces it with an other version
            # this feature is used if there is only a romloader release but no new flasher release.
            # this feature should only be used for a quicktest. a complete version of the flasher is preferred.
            if self.ref_flash.installApplyRomloaderPatch:
                i_err = self.install_romloader_plugin()

                if i_err != 0:
                    l.error("[install][romloader_plugin]: While copy files")
                    break
        else:
            i_err = 0
            l.info("[install]: Successful")

        return i_err

    def gen_name_flasher_archive(self, force32):
        if (force32):
            flasher_version_to_install = 'x86'
        else:
            flasher_version_to_install = self.os["os_cTheMachine"]
        if self.os["os_cOS"] is enLin:
            nameFlasherArchive = 'flasher_cli-%s-ubuntu%s_%s.tar.gz' % (
                self.ref_flash.vFlasher, self.os["os_vLinux"], flasher_version_to_install)
        else:
            nameFlasherArchive = 'flasher_cli-%s-windows_%s.zip' % (self.ref_flash.vFlasher, flasher_version_to_install)
        return nameFlasherArchive

    # ---- transferred from flasher_autorun.py

    def run_command_flasher_helper(self, str_command_flasher, log_file_name=None, path_logfile=None, UUID=''):
        '''
        Execution function for all flasher commands based on command_carrier()
        Expects a command like below. A absoulte path to the binary and the lua-script-file is recommanded.
        A relative path might be possible, but is not tested.

        This function changes the execution directory to the directory where the binary resides.

            /home/aballmert/tmp/flasher/flasher_cli-1.5.4/lua5.1.sh /home/aballmert/tmp/flasher/flasher_cli-1.5.4/cli_flash.lua list_interfaces


        :warning: Do not use this for extra long test output. It is not researched, but it might cause a buffer overflow.
                  better is to provide a file where to put the output.

        :param str_command_flasher: command as specified abouve
        :return: carrier_command wit the result of the command as a string.
        '''

        cmdcarry_flasher = command_carrier()
        cmdcarry_flasher.cmd = str_command_flasher
        cmdcarry_flasher.change_dir_to_bin = True
        if log_file_name:
            if path_logfile is None:
                l.error("[run_cmd_flash_helper]: logfile name provided, but no path!")
                return 1
            cmdcarry_flasher.path_stdout = self.lfm.gen_name_logfiles_man(['O', log_file_name], self.os, UUID)
            cmdcarry_flasher.path_stderr = self.lfm.gen_name_logfiles_man(['E', log_file_name], self.os, UUID)
            l.info('logging to %s and %s' % (cmdcarry_flasher.path_stdout, cmdcarry_flasher.path_stderr))

        l.info("\trun command: %s" % cmdcarry_flasher.cmd)
        runCommandBase(cmdcarry_flasher)
        return cmdcarry_flasher

    def identify_connected_netx(self, list_white=None, list_black=None):
        '''
        development function
        The output of those commands is used to identify the netX. It is more easy to retrive the output from a variable
        instead of retriving it from a special file.
        :param list_white:
        :param list_black:
        :return:
        :argument path_flasher_binary:
        :return: a list of the detected netX, if none are detected, list will be len([]) == 0
        '''
        l.info("[enumerate] Check all available ports for netX")
        tmp_run_command_flasher_listInterfaces = self.gen_list_interfaces()
        car_list_interfaces = self.run_command_flasher_helper(tmp_run_command_flasher_listInterfaces)
        accessable_netX = []  # final list which contains the netX which have responded positive
        if car_list_interfaces.ret_val:
            l.error("List command failed with retval != 0 [%d]" % car_list_interfaces.ret_val)
            l.error("\tcmd: %s" % car_list_interfaces.cmd)
            if car_list_interfaces.str_stderr:
                l.error("\tstderr: %s" % car_list_interfaces.str_stderr)
            if car_list_interfaces.str_stdout:
                l.error("\tstdout: %s" % car_list_interfaces.str_stdout)
        else:
            # success, we shoul have a list
            # todo: clear default wrong infos about a netX 90 connected
            all_netx = self.re_retrive_ports_from_list(car_list_interfaces.str_stdout)

            if len(all_netx) == 0:
                l.error("[enumerate] no netX found")
            else:
                # apply the black and white mask before even touching the netX
                list_black_white = self.apply_whitemask_blacklist(all_netx, list_black, list_white)

                for netx_under_test in list_black_white:

                    # run_command_detect_netx = "%s %s"%(run_command_flasher_base_detectNetx, netx_under_test.port )
                    tmp_car_detect_netx = self.helper_run_cmd_detect_netx(netx_under_test)

                    if (tmp_car_detect_netx.ret_val == 0):
                        # will add name and detected type of the netX to the structure.
                        self.re_retrive_netxProperties_from_list(tmp_car_detect_netx.str_stdout, netx_under_test)
                        accessable_netX.append(netx_under_test)
                        l.info("\t\tfound: [%s] (%s) netX Type: %s " % (
                            netx_under_test[Jasonixer.json_chip_if_port],
                            netx_under_test[Jasonixer.json_chip_type_number],
                            netx_under_test[Jasonixer.json_chip_type_identifyer]))
                    else:
                        # no netX found, display log of detext_netX
                        # todo: write log to logfile
                        l.debug("log from detect_netx: \nstdout: %s \n stderr:\n%s" % (
                            tmp_car_detect_netx.str_stdout, tmp_car_detect_netx.str_stderr))

        l.info("[enumerate] list enumerated netx:")
        for netx in accessable_netX:
            l.info("\t[%s] (%s) netX Type: %s " % (
                netx[Jasonixer.json_chip_if_port],
                netx[Jasonixer.json_chip_type_number],
                netx[Jasonixer.json_chip_type_identifyer]))

        return accessable_netX

    def helper_run_cmd_detect_netx(self, netx_under_test):
        run_command_detect_netx = self.gen_detect_netX(netx_under_test)
        tmp_car_detect_netx = self.run_command_flasher_helper(run_command_detect_netx)
        return tmp_car_detect_netx

    @staticmethod
    def apply_whitemask_blacklist(list_possible_netx, list_black=None, list_white=None):
        """
        Helper identify netX
        If the black/white-string is part of the interface, the interface the list takes action.
        A list evals to false has no effect.
        list_white is summed together. At least one element of the list has to match on a given controller to pass.
        if the given controller is part of one elemnt of the blacklist, the according conttroller is kicked.
        todo: you could expand dis black/white thing as dicts, and then find is key/val exists in the neX dict.
        :param list_possible_netx: json describing the list of avariable netX
        :param blacklist: array containing strings which are evaluated against the list of netX
        :param list_white: array containing strings which are evaluated against the list of netX
        :return: array of json of of the filtered list
        """

        l.info("[enumerate] check netX for black/white-lists")
        # Check if any mask is set
        if not (list_black or list_white):
            # no action necessary
            l.info("[enumerate] No black nor white list set.")
            return list_possible_netx

        p_netx = 0
        p_white = 1
        p_black = 2
        # reason of kick:
        r_white = 3
        r_black = 4

        carrier = []

        if list_black:
            l.info("list_black: %s" % list_black)
            assert (type(list_black) is list)

        if list_white:
            l.info("list_white: %s" % list_white)
            assert (type(list_white) is list)

        # copy netX into working structure
        for it_netx in list_possible_netx:
            #                        white  black
            carrier.append([it_netx, False, True, "", ""])

        # white maks: Summed together, kicks all what is not part of sum. Val carrier_ele[p_white] = False -> kicked
        if list_white:
            for carrier_ele in carrier:
                for white in list_white:
                    if white in carrier_ele[p_netx][Jasonixer.json_chip_if_port]:
                        # passed white
                        carrier_ele[p_white] = True
                        break
                else:
                    carrier_ele[r_white] = "not in white list"

        # blak list: if a element matches, the netX is kicked. carrier_ele[p_black] = False -> kicked
        if list_black:
            for carrier_ele in carrier:
                for black in list_black:
                    if black in carrier_ele[p_netx][Jasonixer.json_chip_if_port]:
                        carrier_ele[p_black] = False
                        carrier_ele[r_black] = black
                        break
        # generate final list
        list_approved_netx = []

        for carrier_ele in carrier:
            tested_netx = carrier_ele[p_netx]
            # this part of the loop is only for dialogue
            if list_white and not (carrier_ele[p_white]):
                l.info("[check][throw] %s @ %s reason(white): %s" % (
                    tested_netx[Jasonixer.json_chip_name], tested_netx[Jasonixer.json_chip_if_port],
                    carrier_ele[r_white]))
                # kicked out by white
                pass
            else:

                # black list:
                if not (list_black and not (carrier_ele[p_black])):
                    l.info("[check][keep ] %s @ %s" % (
                    tested_netx[Jasonixer.json_chip_name], tested_netx[Jasonixer.json_chip_if_port]))
                    list_approved_netx.append(carrier_ele[p_netx])
                    # passed black
                    pass
                else:
                    l.info("[check][throw] %s @ %s reason(black): %s" % (
                    tested_netx[Jasonixer.json_chip_name], tested_netx[Jasonixer.json_chip_if_port],
                    carrier_ele[r_black]))
                    # kicket out by white test

            # check both booleans and add if both are true, e.g. netX has passed both lists
            if carrier_ele[p_white] and carrier_ele[p_black]:
                pass

        return list_approved_netx

    def re_retrive_netxProperties_from_list(self, str_output_detect_netX, netx_Under_test):
        '''
        helper to identify_connected_netx()
        retraversing over given output, because the part will be at the end.
        Stringcompare is used for retrieving the right line and re for extraction.
        It fails if the string compare functions determins the wrong line. one shot only.

        Will analyse the output of detect netx and tries to retrieve more information about it.
        :param str_output_detect_netX:
        :return: -1 in case of error
        '''

        # Chip type: (10) netX90MPW
        re_pattern_netX_Type = 'Chip type:\s\((\d+)\)\s(.*)'
        tmp_list = str_output_detect_netX.split('\n')
        for line in reversed(tmp_list):
            if 'Chip type: (' in line:
                tmatch = re.match(re_pattern_netX_Type, line)
                if tmatch:
                    try:
                        netx_Under_test[Jasonixer.json_chip_type_number] = tmatch.group(1)
                        netx_Under_test[Jasonixer.json_chip_type_identifyer] = tmatch.group(2)
                    except IndexError as ie:
                        l.error("Half recognised line %s" % line)
                        l.error(ie)
                break

        assert (netx_Under_test[Jasonixer.json_chip_type_number] != '')
        assert (netx_Under_test[Jasonixer.json_chip_type_identifyer] != '')

    def gen_detect_netX(self, json_netx):
        '''
        helper to identify_connected_netx()
        generating string for detecting netX
        :param path_flasher_bin: path to binary, preferable absolute. including .sh or .exe, no more, no less
        :param port: the port lik uart_romloader_...
        :json_netx: dict from JASONIXER, subdirectory for only one chip.
        :return: the full command
        '''

        # tmp_path_flasher_root = self.gen_helper_get_binpath(self.ref_flash.gPath_lua_binary)
        tmp_path_flasher_cli = os.path.join(self.ref_flash.gpathAbs_flasher, self.ref_flash.name_file_cliFlash)
        run_command_flasher_base_detect_netx = "{} {} {} -p {}".format(self.ref_flash.gPath_lua_binary,
                                                                       tmp_path_flasher_cli,
                                                                       self.ref_flash.command_flasher_detectNetx,
                                                                       json_netx[Jasonixer.json_chip_if_port])
        return run_command_flasher_base_detect_netx

    def gen_list_interfaces(self):
        '''
        helper for identify connected netX
        Assuming cli_flash.lua in default place, generating path from given lua binary path
        :return: run_command_flasher_listInterfaces
        '''
        tmp_path_flasher_root = os.path.dirname(self.ref_flash.gPath_lua_binary)
        tmp_path_flasher_cli = os.path.join(tmp_path_flasher_root, self.ref_flash.name_file_cliFlash)
        run_command_flasher_listInterfaces = "%s %s %s" % (
            self.ref_flash.gPath_lua_binary, tmp_path_flasher_cli, self.ref_flash.command_flasher_listInterfaces)
        return run_command_flasher_listInterfaces

    def re_retrive_ports_from_list(self, str_list_interface_ouput):
        '''
        String / regex helper for identify_connected_netx()
        Expected is a string formatted as below with non leading width spaces.
        The string may contain other characters, but must contain a line with the content
        'START LIST NOT USED INTERFACES' and 'END LIST INTERFACES'. It is not controlled at which
        position this content is placed or how many additional characters are used. The head and the tail and
        the second and prelast line are discarded. The remaining lines have to be a match to avoid a assertion.

        Retrieved is the position, the 'Name' referenced as port an the Typ referenced as type.

            START LIST NOT USED INTERFACES (5 Interfaces found)

            1 : Name:romloader_usb_01_07            Typ: romloader_usb
            2 : Name:romloader_uart_ttyS0           Typ: romloader_uart
            3 : Name:romloader_uart_ttyS4           Typ: romloader_uart
            4 : Name:romloader_uart_ttyACM0         Typ: romloader_uart
            5 : Name:romloader_jtag_netX90_MPW_COM@NXJTAG-USB@1:2 Typ: romloader_jtag

            END LIST INTERFACES
        todo: you could control the number of interfaces found with the actual match. Be more precise with the regex
        :param output_list_interface: a multi line string containing the output from list_interfaces
        :return: array of class netX with found devices
        '''

        list = str_list_interface_ouput.split('\n')
        assert list
        idx_line_start = None
        idx_line_end = None

        name_idx_start = 'START LIST NOT USED INTERFACES'
        name_idx_end = 'END LIST INTERFACES'

        # circel relevant entries
        for i, item in enumerate(list):
            l.debug("check: [%03d] %s" % (i, item))
            if name_idx_start in item:
                assert idx_line_start is None
                idx_line_start = i

            if name_idx_end in item:
                assert idx_line_end is None
                idx_line_end = i
        if idx_line_start is None or idx_line_end is None:
            l.error("Error looking for indexes: %s / %s" % (name_idx_start, name_idx_end))
            l.error("List output:\n%s" % str_list_interface_ouput)
            assert idx_line_start is not None
            assert idx_line_start is not None

        all_netx = []

        # 1 : Name:romloader_usb_01_07            Typ: romloader_usb
        # 5 : Name:romloader_jtag_netX_ARM966@NXJTAG-USB@1:2 Typ: romloader_jtag
        re_pattern_flasher_listInterfaces = '(\d+) : Name:([\w@\-:\./]+)\s+Typ: (\w+)'
        l.debug("Done got line %d to %d" % (idx_line_start, idx_line_end))

        l.debug("Asimilate Result")
        tmp_loop_begin = idx_line_start + 2
        for i, sorted_line in enumerate(list[tmp_loop_begin:idx_line_end - 1]):  # remove leading and trailing line
            l.info("[% 3d] %s" % (tmp_loop_begin + i, sorted_line))
            tmatch = re.match(re_pattern_flasher_listInterfaces, sorted_line)
            if tmatch is None:
                l.error(
                    "unrecognised pattern in list: %s does not match %s" % (
                        sorted_line, re_pattern_flasher_listInterfaces))
            # m_netx = c_netx()
            try:
                m_netx = Jasonixer.generate_desc_empty_chip(num=None, name=tmatch.group(3), tmp_port=tmatch.group(2))
                m_netx[Jasonixer.json_chip_tmp_it] = tmatch.group(1)


            except IndexError as ie:
                print(ie, '\n[pirate][error][%d]: string had not expected pattern: %s' % (i, sorted_line))
                assert False
            all_netx.append(m_netx)

        l.info("[enumerate] List of detected ports:")
        for netx in all_netx:
            Jasonixer.print_chip(netx)

        return all_netx

    def set_path_flasher_binary(self):
        '''
        Generates the testcommand for the romloader test.
        Output is separated into flasher binary and into command line arguments.
        The split was necessary to use the advanced flasher functions.
        '''

        if self.os['os_cOS'] == enLin:
            name_lua_bin = self.ref_flash.nLuaLin
        else:
            name_lua_bin = self.ref_flash.nLuaWin

        self.ref_flash.gPath_lua_binary = os.path.join(self.ref_flash.gpathAbs_flasher, name_lua_bin)

    # ------------------------ below this line is only tradition. if used, integrate, if not, discard

    def ptbt_flasher_v1(self):
        '''
        Generates and runns command able to test the flasher.
        A full series of tests is executed, without abortiang after a failed test.
        If all tests succeed, 0 is returened else 1.
        :return: number of failed commands
        '''

        logfile_praefix = "flashtest"

        list_possible_netx = identify_connected_netx(flasher_binary)
        if len(list_possible_netx) == 0:
            # no netX could be identified
            l.error("no netX could be identified!")
            numErrors = -1
            # todo: this will be json!


        else:
            port_of_netX = list_possible_netx[0].port

            # communication of what netX is awaited.
            final_json, final_config = init_json_files()
            # boardconfig
            die_config = final_json["test_config"]

            # todo short this call
            # handling json input parameters from the config files

            # some functions used:

            parameters = self.get_default_select_code_from_storage(board)
            test_name = final_config["name_test"]
            test_version = final_config["version"]

        return numErrors

    def apply_test_romloader(self):
        """
        Patch flasher with files necessary for the test_romloader.lua.
        :return: 0 in case of success
        """
        iErr = copyfileByWildcard(self.ref_flash.gPath_binsNetxSourceWild, self.ref_flash.gPath_binsNetxTarget)
        if iErr != 0:
            err_msg = "[pirate][install][error]: Faild to copy binary files! <%s><%s>" % (
                self.ref_flash.gPath_binsNetxSourceWild, self.ref_flash.gPath_binsNetxTarget)
            l.error(err_msg)
            raise (BaseException(err_msg))
        else:
            l.info("[pirate][install][cp]: test_romloader.lua %s -> %s" % (
                self.ref_flash.gPath_LuafileRomloaderSource, self.ref_flash.gPath_LuaFileRomloaderTarget))
            try:
                shutil.copy(self.ref_flash.gPath_LuafileRomloaderSource, self.ref_flash.gPath_LuaFileRomloaderTarget)
            except Exception as e:
                l.error("%s", e)
                l.error("copy of <%s>to<%s> " % (
                    self.ref_flash.gPath_LuafileRomloaderSource, self.ref_flash.gPath_LuaFileRomloaderTarget))
                raise e

    def install_flasher_version_unpack(self, path_tmp_zip_os_flasher):
        # unpack correct version of the flasher
        l.info("[pirate][install][extract]: OS-Flasher")
        l.info("[pirate][install][extract]: TarFlasher: <%s> to <%s>" % (path_tmp_zip_os_flasher, self.gPath_base_root))
        if self.os["os_cOS"] == enLin:
            extractTarGz(path_tmp_zip_os_flasher, self.gPath_base_root)
        else:
            iErr = extractZip(path_tmp_zip_os_flasher, self.gPath_base_root)

    def install_romloader_plugin(self):
        """
        Patches a old flasher with new romloader files.
        This procedure can be necessary when a new romloader is out, but no new flasher release.
        Existing files will be overwritten, new files will be added, otheres remain untouched
        because it is causing some problems to extract xz with python, the archive must contain already extracted folders!
        The name of the Folder is
        :return: 0 in case of success
        """

        raise (BaseException("no longer supported! usage without warranty!"))

        iErr = 1
        if cOS is enLin:
            name_folder_OS_romloader_plugin = 'folder_lua5.1-romloader-%s-ubuntu_%s_%s.tar.xz' % (
                vRomloader, vLinux, cTheMachine)
        else:
            name_folder_OS_romloader_plugin = 'folder_lua5.1-romloader-%s-windows_%s.tar.xz' % (vRomloader, cTheMachine)

        for _ in [1]:
            # extract to romloader_plugin
            name_romloader_plugin_folder = 'romloader_plugin'
            gPath_romloader_plugin_extract = os.path.join(self.gPath_base_root, name_romloader_plugin_folder)
            l.info(
                "[install][romloader_plugin][prep]: remove & create & extract to: %s" % gPath_romloader_plugin_extract)
            shutil.rmtree(gPath_romloader_plugin_extract, ignore_errors=True)
            os.mkdir(gPath_romloader_plugin_extract)
            l.info("[install][romloader_plugin][extract]: from: %s" % gPath_romloader_tar_source)
            l.info("[install][romloader_plugin][extract]: to: %s" % gPath_romloader_plugin_extract)
            iErr = extractTarGz(gPath_romloader_tar_source,
                                gPath_romloader_plugin_extract)  # extract the full archive with content of all romloader archives for different OS
            if iErr:
                l.error("[install][romloader_plugin][extract]: error no %d" % iErr)
                break
            # copy all files from this folder and overwrite the following location

            pathAbs_tmp_folder_src_romloader_plugin = os.path.join(gPath_romloader_plugin_extract,
                                                                   name_folder_OS_romloader_plugin)
            l.info("[install][romloader_plugin][copy]: from %s" % pathAbs_tmp_folder_src_romloader_plugin)
            l.info("[install][romloader_plugin][copy]: to %s" % gpathAbs_flasher)
            try:
                iErr = overwrite_merge_Tree(pathAbs_tmp_folder_src_romloader_plugin, gpathAbs_flasher)
            except IOError as ie:
                l.error("[install][romloader_plugin][copy]: %s" % (ie))
                iErr = 69
            if iErr:
                l.error("[install][romloader_plugin][copy]: during final copy")
                break
        else:
            l.info("[install][romloader_plugin]: Success!")
            iErr = 0

        return iErr


def test_black_white():
    test_netx = []

    test_netx.append(Jasonixer.generate_desc_empty_chip(tmp_port='romloader_uart'))
    test_netx.append(Jasonixer.generate_desc_empty_chip(tmp_port='romloader_jtag'))
    test_netx.append(Jasonixer.generate_desc_empty_chip(tmp_port='romloader_eth'))
    x = EnvFlasher.apply_whitemask_blacklist(test_netx, list_black=['jtag'])  # OK
    # x = EnvFlasher.apply_whitemask_blacklist(test_netx, list_black=['jtag','jtag']) #OK
    # x = EnvFlasher.apply_whitemask_blacklist(test_netx, list_white=['jtag']) #OK
    # x = EnvFlasher.apply_whitemask_blacklist(test_netx, list_white=['jtag','eth']) #ok
    # x = EnvFlasher.apply_whitemask_blacklist(test_netx, list_white=['jtag','eth'],list_black=['eth']) #ok
    print(len(x))
    print("iteration:")
    for lx in x:
        print(" - %s" % lx["netx_port"])


def demo():
    maintained_archive = '/home/aballmert/Downloads/ptbt_now'
    path_file_version_json = os.path.join(maintained_archive, 'version.json')
    log_path = os.path.join(maintained_archive, 'logfiles')
    flasher_env = EnvFlasher(log_path, path_file_version_json, maintained_archive)
    flasher_env.runInstallation()
    flasher_env.identify_connected_netx()


if __name__ == "__main__":
    # todo: install
    # todo: apply test_romloader.lua
    # EnvFlasher('/tmp/logfiles_env_flasher','/home/aballmert/tmp/version.json')
    demo()
    # maintained_archive = '/home/aballmert/Downloads/ptbt_now'
    # path_file_version_json = os.path.join(maintained_archive, 'version.json')
    # log_path = os.path.join(maintained_archive, 'logfiles')
    # flasher_env = EnvFlasher(log_path, path_file_version_json, maintained_archive)

    # args = flasher_env.parser.parse_args(['test','flasher','-m','mid'])
    # pass

    # test_black_white()
